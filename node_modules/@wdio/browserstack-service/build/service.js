"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const logger_1 = __importDefault(require("@wdio/logger"));
const got_1 = __importDefault(require("got"));
const util_1 = require("./util");
const log = logger_1.default('@wdio/browserstack-service');
class BrowserstackService {
    constructor(options = {}, caps, config) {
        this.config = config;
        this.sessionBaseUrl = 'https://api.browserstack.com/automate/sessions';
        this.failReasons = [];
        this.scenariosThatRan = [];
        this.preferScenarioName = Boolean(options.preferScenarioName);
        this.strict = Boolean(config.cucumberOpts && config.cucumberOpts.strict);
        this.failureStatuses = ['failed', 'ambiguous', 'undefined', 'unknown'];
        this.strict && this.failureStatuses.push('pending');
        this.caps = caps;
    }
    beforeSession(config) {
        if (!config.user) {
            config.user = 'NotSetUser';
        }
        if (!config.key) {
            config.key = 'NotSetKey';
        }
        this.config.user = config.user;
        this.config.key = config.key;
    }
    before() {
        const capabilities = global.browser.capabilities || {};
        if (capabilities.app || this.caps.app) {
            this.sessionBaseUrl = 'https://api-cloud.browserstack.com/app-automate/sessions';
        }
        this.scenariosThatRan = [];
        return this._printSessionURL();
    }
    beforeSuite(suite) {
        this.fullTitle = suite.title;
        return this._updateJob({ name: this.fullTitle });
    }
    beforeFeature(uri, feature) {
        this.fullTitle = feature.document.feature.name;
        return this._updateJob({ name: this.fullTitle });
    }
    afterTest(test, context, results) {
        const { error, passed } = results;
        this.fullTitle = (test.fullName ||
            `${test.parent} - ${test.title}`);
        if (!passed) {
            this.failReasons.push((error && error.message) || 'Unknown Error');
        }
    }
    after(result) {
        if (this.preferScenarioName && this.scenariosThatRan.length === 1) {
            this.fullTitle = this.scenariosThatRan.pop();
        }
        const hasReasons = Boolean(this.failReasons.filter(Boolean).length);
        return this._updateJob({
            status: result === 0 ? 'passed' : 'failed',
            name: this.fullTitle,
            reason: hasReasons ? this.failReasons.join('\n') : undefined
        });
    }
    afterScenario(uri, feature, pickle, results) {
        let { exception, status } = results;
        if (status !== 'skipped') {
            this.scenariosThatRan.push(pickle.name);
        }
        if (this.failureStatuses.includes(status)) {
            exception = exception || (status === 'pending'
                ? `Some steps/hooks are pending for scenario "${pickle.name}"`
                : 'Unknown Error');
            this.failReasons.push(exception);
        }
    }
    async onReload(oldSessionId, newSessionId) {
        const hasReasons = Boolean(this.failReasons.filter(Boolean).length);
        let status = hasReasons ? 'failed' : 'passed';
        if (!global.browser.isMultiremote) {
            log.info(`Update (reloaded) job with sessionId ${oldSessionId}, ${status}`);
        }
        else {
            const browserName = global.browser.instances.filter((browserName) => global.browser[browserName].sessionId === newSessionId)[0];
            log.info(`Update (reloaded) multiremote job for browser "${browserName}" and sessionId ${oldSessionId}, ${status}`);
        }
        await this._update(oldSessionId, {
            name: this.fullTitle,
            status,
            reason: hasReasons ? this.failReasons.join('\n') : undefined
        });
        this.scenariosThatRan = [];
        delete this.fullTitle;
        this.failReasons = [];
        await this._printSessionURL();
    }
    _updateJob(requestBody) {
        return this._multiRemoteAction((sessionId) => this._update(sessionId, requestBody));
    }
    _multiRemoteAction(action) {
        if (!global.browser.isMultiremote) {
            log.info(`Update job with sessionId ${global.browser.sessionId}`);
            return action(global.browser.sessionId);
        }
        return Promise.all(global.browser.instances
            .filter(browserName => {
            const cap = util_1.getBrowserCapabilities(this.caps, browserName);
            return util_1.isBrowserstackCapability(cap);
        })
            .map((browserName) => {
            log.info(`Update multiremote job for browser "${browserName}" and sessionId ${global.browser[browserName].sessionId}`);
            return action(global.browser[browserName].sessionId, browserName);
        }));
    }
    _update(sessionId, requestBody) {
        const sessionUrl = `${this.sessionBaseUrl}/${sessionId}.json`;
        log.debug(`Updating Browserstack session at ${sessionUrl} with request body: `, requestBody);
        return got_1.default.put(sessionUrl, {
            json: requestBody,
            username: this.config.user,
            password: this.config.key
        });
    }
    async _printSessionURL() {
        await this._multiRemoteAction(async (sessionId, browserName) => {
            const sessionUrl = `${this.sessionBaseUrl}/${sessionId}.json`;
            log.debug(`Requesting Browserstack session URL at ${sessionUrl}`);
            const response = await got_1.default(sessionUrl, {
                username: this.config.user,
                password: this.config.key,
                responseType: 'json'
            });
            const capabilities = util_1.getBrowserCapabilities(this.caps, browserName);
            const browserString = util_1.getBrowserDescription(capabilities);
            log.info(`${browserString} session: ${response.body.automation_session.browser_url}`);
        });
    }
}
exports.default = BrowserstackService;
